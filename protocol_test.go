package jsonrpc2

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/rpc"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"testing"
)

// Svc is an RPC service for testing.
type Svc struct{}

func (*Svc) Sum(vals [2]int, res *int) error {
	*res = vals[0] + vals[1]
	return nil
}

func (*Svc) Err(struct{}, *struct{}) error {
	return errors.New("some issue")
}

func init() {
	_ = rpc.Register(&Svc{})
}

// Helpers

// caller return string which will overwrite testing.Log's caller with real one.
func caller() string {
	for skip := 1; ; skip++ {
		pc, _, _, ok := runtime.Caller(skip)
		if !ok {
			break
		}
		if strings.Index(runtime.FuncForPC(pc).Name(), ".Test") != -1 {
			return fmt.Sprintf("\r\t%*s\r\t%s: ", len(callerPos(1)), "", callerPos(skip))
		}
	}
	return ""
}

// callerPos return caller's info formatted in way used by testing.Log.
func callerPos(skip int) string {
	_, file, line, ok := runtime.Caller(1 + skip)
	if ok {
		file = filepath.Base(file)
	} else {
		file, line = "???", 1
	}
	return fmt.Sprintf("%s:%d", file, line)
}

func dump(got, want interface{}) string {
	if fmt.Sprintf("%T", got) != fmt.Sprintf("%T", want) {
		return fmt.Sprintf("exp: (%T) %#[1]v\ngot: (%T) %#[2]v\n", want, got)
	}
	return fmt.Sprintf("exp: %#v\ngot: %#v\n", want, got)
}

// testClient check output generated by client.Call().
func testClient(t *testing.T, client *rpc.Client, buf *bufio.Reader, method string, in interface{}, want string) {
	go client.Call(method, in, new(struct{}))
	got, err := buf.ReadString('\n')
	if err != nil {
		t.Fatalf("srv.Read(), err =", err)
	}
	got = strings.TrimRight(got, "\n")

	var jgot, jwant interface{}
	if err := json.Unmarshal([]byte(got), &jgot); err != nil {
		t.Errorf("%s%s(%v), output err = %v\ngot: %#q", caller(), method, in, err, got)
	}
	if err := json.Unmarshal([]byte(want), &jwant); err != nil {
		t.Errorf("%s%s(%v), expect err = %v\nexp: %#q", caller(), method, in, err, want)
	}
	if !reflect.DeepEqual(jgot, jwant) {
		t.Errorf("%s%s(%v)\nexp: %#q\ngot: %#q", caller(), method, in, want, got)
	}
}

// Tests

func TestServer2(t *testing.T) {
	cases := []struct {
		in   string
		want string
	}{
		{
			`{"jsonrpc":"2.0","id":3,"method":"Svc.Sum","params":[[3,5]]}`,
			`{"jsonrpc":"2.0","id":3,"result":8,"error":null}`,
		},
		{
			`{"jsonrpc":"2.0","id":0,"method":"Svc.Err","params":[]}`,
			`{"jsonrpc":"2.0","id":0,"result":null,"error":"some issue"}`,
		},
	}

	for _, c := range cases {
		cli, srv := net.Pipe()
		defer cli.Close()
		go ServeConn(srv)
		buf := bufio.NewReader(cli)

		_, err := cli.Write([]byte(c.in))
		if err != nil {
			t.Errorf("sent err = %v\nsent: %#q", err, c.in)
			continue
		}
		got, err := buf.ReadString('\n')
		if err != nil {
			var jin interface{}
			if err2 := json.Unmarshal([]byte(c.in), &jin); err2 != nil {
				t.Errorf("input err = %v", err2)
			}
			t.Errorf("recv err = %v\nsent: %#q", err, c.in)
			continue
		}
		got = strings.TrimRight(got, "\n")

		var jgot, jwant interface{}
		if err := json.Unmarshal([]byte(got), &jgot); err != nil {
			t.Errorf("output err = %v\nsent: %#q\nrecv: %#q", err, c.in, got)
		}
		if err := json.Unmarshal([]byte(c.want), &jwant); err != nil {
			t.Errorf("expect err = %v\nsent: %#q\nwant: %#q", err, c.in, c.want)
		}
		if !reflect.DeepEqual(jgot, jwant) {
			t.Errorf("\nsent: %#q\nwant: %#q\nrecv: %#q", c.in, c.want, got)
		}
	}
}

func TestClient2(t *testing.T) {
	cases := []struct {
		method string
		in     interface{}
		want   string
	}{
		{
			"Svc.Sum", [2]int{3, 5},
			`{"jsonrpc":"2.0","id":0,"method":"Svc.Sum","params":[[3,5]]}`,
		},
		{
			"Svc.Err", struct{}{},
			`{"jsonrpc":"2.0","id":0,"method":"Svc.Err","params":[{}]}`,
		},
		{
			"Svc.Err", nil,
			`{"jsonrpc":"2.0","id":0,"method":"Svc.Err","params":[null]}`,
		},
		{
			"", "",
			`{"jsonrpc":"2.0","id":0,"method":"","params":[""]}`,
		},
	}

	for _, c := range cases {
		cli, srv := net.Pipe()
		defer srv.Close()
		client := NewClient(cli)
		defer client.Close()
		buf := bufio.NewReader(srv)

		testClient(t, client, buf, c.method, c.in, c.want)
	}
}

func TestClient2_multi(t *testing.T) {
	cases := []struct {
		method string
		in     [2]int
		want   string
	}{
		{"Svc.Sum", [2]int{3, 5}, `{"jsonrpc":"2.0","id":0,"method":"Svc.Sum","params":[[3,5]]}`},
		{"Svc.Err", [2]int{0, 0}, `{"jsonrpc":"2.0","id":1,"method":"Svc.Err","params":[[0,0]]}`},
		{"Svc.Sum", [2]int{3, 5}, `{"jsonrpc":"2.0","id":2,"method":"Svc.Sum","params":[[3,5]]}`},
	}

	cli, srv := net.Pipe()
	defer srv.Close()
	client := NewClient(cli)
	defer client.Close()
	buf := bufio.NewReader(srv)

	for _, c := range cases {
		testClient(t, client, buf, c.method, c.in, c.want)
	}
}

func TestCall(t *testing.T) {
	cases := []struct {
		method  string
		in      interface{}
		want    interface{}
		wanterr error
	}{
		{"Svc.Sum", nil, 0.0, nil},
		{"Svc.Sum", [2]int{}, 0.0, nil},
		{"Svc.Sum", [2]int{3, 5}, 8.0, nil},
		{"Svc.Sum", [2]int{-3, 5}, 2.0, nil},

		{"Svc.Err", struct{}{}, struct{}{}, errors.New("some issue")},
		{"Svc.Err", nil, struct{}{}, errors.New("some issue")},
		{"Svc.Err", 0, struct{}{}, errors.New("json: cannot unmarshal number into Go value of type struct {}")},
	}

	for _, c := range cases {
		cli, srv := net.Pipe()
		go ServeConn(srv)
		client := NewClient(cli)
		defer client.Close()

		got := reflect.Zero(reflect.TypeOf(c.want)).Interface()
		err := client.Call(c.method, c.in, &got)
		if err == nil && c.wanterr != nil || err != nil && (c.wanterr == nil || err.Error() != c.wanterr.Error()) {
			t.Errorf("%s(%v), err = %v, wanterr = %v", c.method, c.in, err, c.wanterr)
		}
		if !reflect.DeepEqual(got, c.want) {
			t.Errorf("%s(%v)\n%s", c.method, c.in, dump(got, c.want))
		}
	}
}
